{"version":3,"sources":["webpack:///0.b94e8769283a980beffc.hot-update.js","webpack:///./public/client/index.js?85bc","webpack:///./~/_react-router-redux@4.0.8@react-router-redux/lib/actions.js?fd28","webpack:///./~/_react-router-redux@4.0.8@react-router-redux/lib/reducer.js?88fa","webpack:///./~/_react-router-redux@4.0.8@react-router-redux/lib/index.js?97cf","webpack:///./~/_react-router-redux@4.0.8@react-router-redux/lib/middleware.js?6c4b","webpack:///./~/_react-router-redux@4.0.8@react-router-redux/lib/sync.js?8324"],"names":["webpackHotUpdate","44","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_react","_react2","_reactDom","_reactRedux","_createBrowserHistory","_createBrowserHistory2","_configureStore","_configureStore2","_components","_components2","rootEl","document","getElementById","store","history","unlisten","location","listen","action","console","log","pathname","state","render","createElement","Provider","push","some","92","updateLocation","method","_len","arguments","length","args","Array","_key","type","CALL_HISTORY_METHOD","payload","Object","defineProperty","value","replace","go","goBack","goForward","routerActions","93","routerReducer","initialState","_ref","LOCATION_CHANGE","_extends","locationBeforeTransitions","assign","target","i","source","key","prototype","hasOwnProperty","call","94","routerMiddleware","syncHistoryWithStore","_reducer","enumerable","get","_actions","_sync","_sync2","_middleware","_middleware2","95","_toConsumableArray","arr","isArray","arr2","from","next","_action$payload","apply","96","_ref$selectLocationSt","selectLocationState","defaultSelectLocationState","_ref$adjustUrlOnRepla","adjustUrlOnReplay","getState","Error","initialLocation","isTimeTraveling","unsubscribeFromStore","unsubscribeFromHistory","currentLocation","getLocationInStore","useInitialIfEmpty","handleStoreChange","locationInStore","transitionTo","subscribe","handleLocationChange","dispatch","getCurrentLocation","listener","lastPublishedLocation","unsubscribed","unsubscribe","routing"],"mappings":"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","file":"0.b94e8769283a980beffc.hot-update.js","sourcesContent":["webpackHotUpdate(0,{\n\n/***/ 44:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _react = __webpack_require__(0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(0);\n\nvar _reactRedux = __webpack_require__(5);\n\nvar _createBrowserHistory = __webpack_require__(38);\n\nvar _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);\n\nvar _reactRouter = __webpack_require__(81);\n\nvar _reactRouterRedux = __webpack_require__(94);\n\nvar _configureStore = __webpack_require__(37);\n\nvar _configureStore2 = _interopRequireDefault(_configureStore);\n\nvar _components = __webpack_require__(36);\n\nvar _components2 = _interopRequireDefault(_components);\n\nvar _preact = __webpack_require__(39);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar rootEl = document.getElementById('root');\nvar store = _configureStore2.default;\nvar history = (0, _createBrowserHistory2.default)();\n\n// Get the current location.\nvar location = history.location;\n\n// Listen for changes to the current location.\nvar unlisten = history.listen(function (location, action) {\n  // location is an object like window.location\n  console.log(action, location.pathname, location.state);\n  (0, _reactDom.render)(_react2.default.createElement(\n    _reactRedux.Provider,\n    { store: store },\n    _react2.default.createElement(_components2.default, null)\n  ), rootEl);\n});\n\n// Use push, replace, and go to navigate around.\nhistory.push('/', { some: 'state' });\n\n// To stop listening, call the function returned from listen().\nunlisten();\n//react-redux 提供Provider组件，可以让容器组件拿到state。\n//Provider在根组件外面包了一层，这样一来，根组件的所有子组件就默认都可以拿到state了。\n//render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。\n//再次render()，只附加事件处理程序，从而拥有非常高性能的第一次加载体验。\n// render(\n//   <Provider store={store}>\n//     <Index />\n//   </Provider>,\n//   rootEl\n// )\n\n/***/ }),\n\n/***/ 92:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * This action type will be dispatched by the history actions below.\n * If you're writing a middleware to watch for navigation events, be sure to\n * look for actions of this type.\n */\nvar CALL_HISTORY_METHOD = exports.CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';\n\nfunction updateLocation(method) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return {\n      type: CALL_HISTORY_METHOD,\n      payload: { method: method, args: args }\n    };\n  };\n}\n\n/**\n * These actions correspond to the history API.\n * The associated routerMiddleware will capture these events before they get to\n * your reducer and reissue them as the matching function on your history.\n */\nvar push = exports.push = updateLocation('push');\nvar replace = exports.replace = updateLocation('replace');\nvar go = exports.go = updateLocation('go');\nvar goBack = exports.goBack = updateLocation('goBack');\nvar goForward = exports.goForward = updateLocation('goForward');\n\nvar routerActions = exports.routerActions = { push: push, replace: replace, go: go, goBack: goBack, goForward: goForward };\n\n/***/ }),\n\n/***/ 93:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.routerReducer = routerReducer;\n/**\n * This action type will be dispatched when your history\n * receives a location change.\n */\nvar LOCATION_CHANGE = exports.LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\n\nvar initialState = {\n  locationBeforeTransitions: null\n};\n\n/**\n * This reducer will update the state with the most recent location history\n * has transitioned to. This may not be in sync with the router, particularly\n * if you have asynchronously-loaded routes, so reading from and relying on\n * this state is discouraged.\n */\nfunction routerReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      type = _ref.type,\n      payload = _ref.payload;\n\n  if (type === LOCATION_CHANGE) {\n    return _extends({}, state, { locationBeforeTransitions: payload });\n  }\n\n  return state;\n}\n\n/***/ }),\n\n/***/ 94:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.routerMiddleware = exports.routerActions = exports.goForward = exports.goBack = exports.go = exports.replace = exports.push = exports.CALL_HISTORY_METHOD = exports.routerReducer = exports.LOCATION_CHANGE = exports.syncHistoryWithStore = undefined;\n\nvar _reducer = __webpack_require__(93);\n\nObject.defineProperty(exports, 'LOCATION_CHANGE', {\n  enumerable: true,\n  get: function get() {\n    return _reducer.LOCATION_CHANGE;\n  }\n});\nObject.defineProperty(exports, 'routerReducer', {\n  enumerable: true,\n  get: function get() {\n    return _reducer.routerReducer;\n  }\n});\n\nvar _actions = __webpack_require__(92);\n\nObject.defineProperty(exports, 'CALL_HISTORY_METHOD', {\n  enumerable: true,\n  get: function get() {\n    return _actions.CALL_HISTORY_METHOD;\n  }\n});\nObject.defineProperty(exports, 'push', {\n  enumerable: true,\n  get: function get() {\n    return _actions.push;\n  }\n});\nObject.defineProperty(exports, 'replace', {\n  enumerable: true,\n  get: function get() {\n    return _actions.replace;\n  }\n});\nObject.defineProperty(exports, 'go', {\n  enumerable: true,\n  get: function get() {\n    return _actions.go;\n  }\n});\nObject.defineProperty(exports, 'goBack', {\n  enumerable: true,\n  get: function get() {\n    return _actions.goBack;\n  }\n});\nObject.defineProperty(exports, 'goForward', {\n  enumerable: true,\n  get: function get() {\n    return _actions.goForward;\n  }\n});\nObject.defineProperty(exports, 'routerActions', {\n  enumerable: true,\n  get: function get() {\n    return _actions.routerActions;\n  }\n});\n\nvar _sync = __webpack_require__(96);\n\nvar _sync2 = _interopRequireDefault(_sync);\n\nvar _middleware = __webpack_require__(95);\n\nvar _middleware2 = _interopRequireDefault(_middleware);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nexports.syncHistoryWithStore = _sync2['default'];\nexports.routerMiddleware = _middleware2['default'];\n\n/***/ }),\n\n/***/ 95:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = routerMiddleware;\n\nvar _actions = __webpack_require__(92);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * This middleware captures CALL_HISTORY_METHOD actions to redirect to the\n * provided history object. This will prevent these actions from reaching your\n * reducer or any middleware that comes after this one.\n */\nfunction routerMiddleware(history) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type !== _actions.CALL_HISTORY_METHOD) {\n          return next(action);\n        }\n\n        var _action$payload = action.payload,\n            method = _action$payload.method,\n            args = _action$payload.args;\n\n        history[method].apply(history, _toConsumableArray(args));\n      };\n    };\n  };\n}\n\n/***/ }),\n\n/***/ 96:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports['default'] = syncHistoryWithStore;\n\nvar _reducer = __webpack_require__(93);\n\nvar defaultSelectLocationState = function defaultSelectLocationState(state) {\n  return state.routing;\n};\n\n/**\n * This function synchronizes your history state with the Redux store.\n * Location changes flow from history to the store. An enhanced history is\n * returned with a listen method that responds to store updates for location.\n *\n * When this history is provided to the router, this means the location data\n * will flow like this:\n * history.push -> store.dispatch -> enhancedHistory.listen -> router\n * This ensures that when the store state changes due to a replay or other\n * event, the router will be updated appropriately and can transition to the\n * correct router state.\n */\nfunction syncHistoryWithStore(history, store) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$selectLocationSt = _ref.selectLocationState,\n      selectLocationState = _ref$selectLocationSt === undefined ? defaultSelectLocationState : _ref$selectLocationSt,\n      _ref$adjustUrlOnRepla = _ref.adjustUrlOnReplay,\n      adjustUrlOnReplay = _ref$adjustUrlOnRepla === undefined ? true : _ref$adjustUrlOnRepla;\n\n  // Ensure that the reducer is mounted on the store and functioning properly.\n  if (typeof selectLocationState(store.getState()) === 'undefined') {\n    throw new Error('Expected the routing state to be available either as `state.routing` ' + 'or as the custom expression you can specify as `selectLocationState` ' + 'in the `syncHistoryWithStore()` options. ' + 'Ensure you have added the `routerReducer` to your store\\'s ' + 'reducers via `combineReducers` or whatever method you use to isolate ' + 'your reducers.');\n  }\n\n  var initialLocation = void 0;\n  var isTimeTraveling = void 0;\n  var unsubscribeFromStore = void 0;\n  var unsubscribeFromHistory = void 0;\n  var currentLocation = void 0;\n\n  // What does the store say about current location?\n  var getLocationInStore = function getLocationInStore(useInitialIfEmpty) {\n    var locationState = selectLocationState(store.getState());\n    return locationState.locationBeforeTransitions || (useInitialIfEmpty ? initialLocation : undefined);\n  };\n\n  // Init initialLocation with potential location in store\n  initialLocation = getLocationInStore();\n\n  // If the store is replayed, update the URL in the browser to match.\n  if (adjustUrlOnReplay) {\n    var handleStoreChange = function handleStoreChange() {\n      var locationInStore = getLocationInStore(true);\n      if (currentLocation === locationInStore || initialLocation === locationInStore) {\n        return;\n      }\n\n      // Update address bar to reflect store state\n      isTimeTraveling = true;\n      currentLocation = locationInStore;\n      history.transitionTo(_extends({}, locationInStore, {\n        action: 'PUSH'\n      }));\n      isTimeTraveling = false;\n    };\n\n    unsubscribeFromStore = store.subscribe(handleStoreChange);\n    handleStoreChange();\n  }\n\n  // Whenever location changes, dispatch an action to get it in the store\n  var handleLocationChange = function handleLocationChange(location) {\n    // ... unless we just caused that location change\n    if (isTimeTraveling) {\n      return;\n    }\n\n    // Remember where we are\n    currentLocation = location;\n\n    // Are we being called for the first time?\n    if (!initialLocation) {\n      // Remember as a fallback in case state is reset\n      initialLocation = location;\n\n      // Respect persisted location, if any\n      if (getLocationInStore()) {\n        return;\n      }\n    }\n\n    // Tell the store to update by dispatching an action\n    store.dispatch({\n      type: _reducer.LOCATION_CHANGE,\n      payload: location\n    });\n  };\n  unsubscribeFromHistory = history.listen(handleLocationChange);\n\n  // History 3.x doesn't call listen synchronously, so fire the initial location change ourselves\n  if (history.getCurrentLocation) {\n    handleLocationChange(history.getCurrentLocation());\n  }\n\n  // The enhanced history uses store as source of truth\n  return _extends({}, history, {\n    // The listeners are subscribed to the store instead of history\n    listen: function listen(listener) {\n      // Copy of last location.\n      var lastPublishedLocation = getLocationInStore(true);\n\n      // Keep track of whether we unsubscribed, as Redux store\n      // only applies changes in subscriptions on next dispatch\n      var unsubscribed = false;\n      var unsubscribeFromStore = store.subscribe(function () {\n        var currentLocation = getLocationInStore(true);\n        if (currentLocation === lastPublishedLocation) {\n          return;\n        }\n        lastPublishedLocation = currentLocation;\n        if (!unsubscribed) {\n          listener(lastPublishedLocation);\n        }\n      });\n\n      // History 2.x listeners expect a synchronous call. Make the first call to the\n      // listener after subscribing to the store, in case the listener causes a\n      // location change (e.g. when it redirects)\n      if (!history.getCurrentLocation) {\n        listener(lastPublishedLocation);\n      }\n\n      // Let user unsubscribe later\n      return function () {\n        unsubscribed = true;\n        unsubscribeFromStore();\n      };\n    },\n\n\n    // It also provides a way to destroy internal listeners\n    unsubscribe: function unsubscribe() {\n      if (adjustUrlOnReplay) {\n        unsubscribeFromStore();\n      }\n      unsubscribeFromHistory();\n    }\n  });\n}\n\n/***/ })\n\n})\n\n\n// WEBPACK FOOTER //\n// 0.b94e8769283a980beffc.hot-update.js","import React from 'react';\nimport { render } from 'react-dom';\nimport { Provider } from 'react-redux';\nimport createHistory from \"history/createBrowserHistory\";\n\nimport { Router, Route, browserHistory } from 'react-router'\nimport { syncHistoryWithStore, routerReducer } from 'react-router-redux'\n\nimport configureStore from './store/configureStore';\nimport Index from './components';\nimport { h, Component } from 'preact';\n\nconst rootEl = document.getElementById('root');\nconst store = configureStore;\nconst history = createHistory();\n \n// Get the current location.\nconst location = history.location\n \n// Listen for changes to the current location.\nconst unlisten = history.listen((location, action) => {\n  // location is an object like window.location\n  console.log(action, location.pathname, location.state);\n  render(\n  <Provider store={store}>\n    <Index />\n  </Provider>,\n  rootEl\n)\n})\n \n// Use push, replace, and go to navigate around.\nhistory.push('/', { some: 'state' })\n \n// To stop listening, call the function returned from listen().\nunlisten()\n//react-redux 提供Provider组件，可以让容器组件拿到state。\n//Provider在根组件外面包了一层，这样一来，根组件的所有子组件就默认都可以拿到state了。\n//render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。\n//再次render()，只附加事件处理程序，从而拥有非常高性能的第一次加载体验。\n// render(\n//   <Provider store={store}>\n//     <Index />\n//   </Provider>,\n//   rootEl\n// )\n\n\n\n// WEBPACK FOOTER //\n// ./public/client/index.js","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * This action type will be dispatched by the history actions below.\n * If you're writing a middleware to watch for navigation events, be sure to\n * look for actions of this type.\n */\nvar CALL_HISTORY_METHOD = exports.CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';\n\nfunction updateLocation(method) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return {\n      type: CALL_HISTORY_METHOD,\n      payload: { method: method, args: args }\n    };\n  };\n}\n\n/**\n * These actions correspond to the history API.\n * The associated routerMiddleware will capture these events before they get to\n * your reducer and reissue them as the matching function on your history.\n */\nvar push = exports.push = updateLocation('push');\nvar replace = exports.replace = updateLocation('replace');\nvar go = exports.go = updateLocation('go');\nvar goBack = exports.goBack = updateLocation('goBack');\nvar goForward = exports.goForward = updateLocation('goForward');\n\nvar routerActions = exports.routerActions = { push: push, replace: replace, go: go, goBack: goBack, goForward: goForward };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_react-router-redux@4.0.8@react-router-redux/lib/actions.js\n// module id = 92\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.routerReducer = routerReducer;\n/**\n * This action type will be dispatched when your history\n * receives a location change.\n */\nvar LOCATION_CHANGE = exports.LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\n\nvar initialState = {\n  locationBeforeTransitions: null\n};\n\n/**\n * This reducer will update the state with the most recent location history\n * has transitioned to. This may not be in sync with the router, particularly\n * if you have asynchronously-loaded routes, so reading from and relying on\n * this state is discouraged.\n */\nfunction routerReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      type = _ref.type,\n      payload = _ref.payload;\n\n  if (type === LOCATION_CHANGE) {\n    return _extends({}, state, { locationBeforeTransitions: payload });\n  }\n\n  return state;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_react-router-redux@4.0.8@react-router-redux/lib/reducer.js\n// module id = 93\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.routerMiddleware = exports.routerActions = exports.goForward = exports.goBack = exports.go = exports.replace = exports.push = exports.CALL_HISTORY_METHOD = exports.routerReducer = exports.LOCATION_CHANGE = exports.syncHistoryWithStore = undefined;\n\nvar _reducer = require('./reducer');\n\nObject.defineProperty(exports, 'LOCATION_CHANGE', {\n  enumerable: true,\n  get: function get() {\n    return _reducer.LOCATION_CHANGE;\n  }\n});\nObject.defineProperty(exports, 'routerReducer', {\n  enumerable: true,\n  get: function get() {\n    return _reducer.routerReducer;\n  }\n});\n\nvar _actions = require('./actions');\n\nObject.defineProperty(exports, 'CALL_HISTORY_METHOD', {\n  enumerable: true,\n  get: function get() {\n    return _actions.CALL_HISTORY_METHOD;\n  }\n});\nObject.defineProperty(exports, 'push', {\n  enumerable: true,\n  get: function get() {\n    return _actions.push;\n  }\n});\nObject.defineProperty(exports, 'replace', {\n  enumerable: true,\n  get: function get() {\n    return _actions.replace;\n  }\n});\nObject.defineProperty(exports, 'go', {\n  enumerable: true,\n  get: function get() {\n    return _actions.go;\n  }\n});\nObject.defineProperty(exports, 'goBack', {\n  enumerable: true,\n  get: function get() {\n    return _actions.goBack;\n  }\n});\nObject.defineProperty(exports, 'goForward', {\n  enumerable: true,\n  get: function get() {\n    return _actions.goForward;\n  }\n});\nObject.defineProperty(exports, 'routerActions', {\n  enumerable: true,\n  get: function get() {\n    return _actions.routerActions;\n  }\n});\n\nvar _sync = require('./sync');\n\nvar _sync2 = _interopRequireDefault(_sync);\n\nvar _middleware = require('./middleware');\n\nvar _middleware2 = _interopRequireDefault(_middleware);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nexports.syncHistoryWithStore = _sync2['default'];\nexports.routerMiddleware = _middleware2['default'];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_react-router-redux@4.0.8@react-router-redux/lib/index.js\n// module id = 94\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = routerMiddleware;\n\nvar _actions = require('./actions');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * This middleware captures CALL_HISTORY_METHOD actions to redirect to the\n * provided history object. This will prevent these actions from reaching your\n * reducer or any middleware that comes after this one.\n */\nfunction routerMiddleware(history) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type !== _actions.CALL_HISTORY_METHOD) {\n          return next(action);\n        }\n\n        var _action$payload = action.payload,\n            method = _action$payload.method,\n            args = _action$payload.args;\n\n        history[method].apply(history, _toConsumableArray(args));\n      };\n    };\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_react-router-redux@4.0.8@react-router-redux/lib/middleware.js\n// module id = 95\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports['default'] = syncHistoryWithStore;\n\nvar _reducer = require('./reducer');\n\nvar defaultSelectLocationState = function defaultSelectLocationState(state) {\n  return state.routing;\n};\n\n/**\n * This function synchronizes your history state with the Redux store.\n * Location changes flow from history to the store. An enhanced history is\n * returned with a listen method that responds to store updates for location.\n *\n * When this history is provided to the router, this means the location data\n * will flow like this:\n * history.push -> store.dispatch -> enhancedHistory.listen -> router\n * This ensures that when the store state changes due to a replay or other\n * event, the router will be updated appropriately and can transition to the\n * correct router state.\n */\nfunction syncHistoryWithStore(history, store) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$selectLocationSt = _ref.selectLocationState,\n      selectLocationState = _ref$selectLocationSt === undefined ? defaultSelectLocationState : _ref$selectLocationSt,\n      _ref$adjustUrlOnRepla = _ref.adjustUrlOnReplay,\n      adjustUrlOnReplay = _ref$adjustUrlOnRepla === undefined ? true : _ref$adjustUrlOnRepla;\n\n  // Ensure that the reducer is mounted on the store and functioning properly.\n  if (typeof selectLocationState(store.getState()) === 'undefined') {\n    throw new Error('Expected the routing state to be available either as `state.routing` ' + 'or as the custom expression you can specify as `selectLocationState` ' + 'in the `syncHistoryWithStore()` options. ' + 'Ensure you have added the `routerReducer` to your store\\'s ' + 'reducers via `combineReducers` or whatever method you use to isolate ' + 'your reducers.');\n  }\n\n  var initialLocation = void 0;\n  var isTimeTraveling = void 0;\n  var unsubscribeFromStore = void 0;\n  var unsubscribeFromHistory = void 0;\n  var currentLocation = void 0;\n\n  // What does the store say about current location?\n  var getLocationInStore = function getLocationInStore(useInitialIfEmpty) {\n    var locationState = selectLocationState(store.getState());\n    return locationState.locationBeforeTransitions || (useInitialIfEmpty ? initialLocation : undefined);\n  };\n\n  // Init initialLocation with potential location in store\n  initialLocation = getLocationInStore();\n\n  // If the store is replayed, update the URL in the browser to match.\n  if (adjustUrlOnReplay) {\n    var handleStoreChange = function handleStoreChange() {\n      var locationInStore = getLocationInStore(true);\n      if (currentLocation === locationInStore || initialLocation === locationInStore) {\n        return;\n      }\n\n      // Update address bar to reflect store state\n      isTimeTraveling = true;\n      currentLocation = locationInStore;\n      history.transitionTo(_extends({}, locationInStore, {\n        action: 'PUSH'\n      }));\n      isTimeTraveling = false;\n    };\n\n    unsubscribeFromStore = store.subscribe(handleStoreChange);\n    handleStoreChange();\n  }\n\n  // Whenever location changes, dispatch an action to get it in the store\n  var handleLocationChange = function handleLocationChange(location) {\n    // ... unless we just caused that location change\n    if (isTimeTraveling) {\n      return;\n    }\n\n    // Remember where we are\n    currentLocation = location;\n\n    // Are we being called for the first time?\n    if (!initialLocation) {\n      // Remember as a fallback in case state is reset\n      initialLocation = location;\n\n      // Respect persisted location, if any\n      if (getLocationInStore()) {\n        return;\n      }\n    }\n\n    // Tell the store to update by dispatching an action\n    store.dispatch({\n      type: _reducer.LOCATION_CHANGE,\n      payload: location\n    });\n  };\n  unsubscribeFromHistory = history.listen(handleLocationChange);\n\n  // History 3.x doesn't call listen synchronously, so fire the initial location change ourselves\n  if (history.getCurrentLocation) {\n    handleLocationChange(history.getCurrentLocation());\n  }\n\n  // The enhanced history uses store as source of truth\n  return _extends({}, history, {\n    // The listeners are subscribed to the store instead of history\n    listen: function listen(listener) {\n      // Copy of last location.\n      var lastPublishedLocation = getLocationInStore(true);\n\n      // Keep track of whether we unsubscribed, as Redux store\n      // only applies changes in subscriptions on next dispatch\n      var unsubscribed = false;\n      var unsubscribeFromStore = store.subscribe(function () {\n        var currentLocation = getLocationInStore(true);\n        if (currentLocation === lastPublishedLocation) {\n          return;\n        }\n        lastPublishedLocation = currentLocation;\n        if (!unsubscribed) {\n          listener(lastPublishedLocation);\n        }\n      });\n\n      // History 2.x listeners expect a synchronous call. Make the first call to the\n      // listener after subscribing to the store, in case the listener causes a\n      // location change (e.g. when it redirects)\n      if (!history.getCurrentLocation) {\n        listener(lastPublishedLocation);\n      }\n\n      // Let user unsubscribe later\n      return function () {\n        unsubscribed = true;\n        unsubscribeFromStore();\n      };\n    },\n\n\n    // It also provides a way to destroy internal listeners\n    unsubscribe: function unsubscribe() {\n      if (adjustUrlOnReplay) {\n        unsubscribeFromStore();\n      }\n      unsubscribeFromHistory();\n    }\n  });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_react-router-redux@4.0.8@react-router-redux/lib/sync.js\n// module id = 96\n// module chunks = 0"],"sourceRoot":""}