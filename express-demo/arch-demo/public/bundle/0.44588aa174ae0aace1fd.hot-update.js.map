{"version":3,"sources":["webpack:///0.44588aa174ae0aace1fd.hot-update.js","webpack:///./public/client/components/index.js?3bf9","webpack:///./~/_react-router-redux@4.0.8@react-router-redux/lib/actions.js?fd28","webpack:///./~/_react-router-redux@4.0.8@react-router-redux/lib/reducer.js?88fa","webpack:///./~/_react-router-redux@4.0.8@react-router-redux/lib/index.js?97cf","webpack:///./~/_react-router-redux@4.0.8@react-router-redux/lib/middleware.js?6c4b","webpack:///./~/_react-router-redux@4.0.8@react-router-redux/lib/sync.js?8324"],"names":["webpackHotUpdate","35","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_react","_react2","_propTypes","_reactRouter","_actions","_title","newObj","hasOwnProperty","_app","_app2","_content","_increase","_decrease","_historyMiddle","Index","_React$Component","this","getPrototypeOf","nextProps","nextState","prevProps","prevState","createElement","CountContent","Component","_React$Component2","apply","arguments","e","console","log","Router","history","browserHistory","Route","path","component","className","hasData","91","updateLocation","method","_len","args","Array","_key","type","CALL_HISTORY_METHOD","payload","push","replace","go","goBack","goForward","routerActions","92","routerReducer","state","initialState","_ref","LOCATION_CHANGE","_extends","locationBeforeTransitions","assign","source","93","routerMiddleware","syncHistoryWithStore","_reducer","get","_sync","_sync2","_middleware","_middleware2","94","_toConsumableArray","arr","isArray","arr2","from","next","action","_action$payload","95","store","_ref$selectLocationSt","selectLocationState","defaultSelectLocationState","_ref$adjustUrlOnRepla","adjustUrlOnReplay","getState","Error","initialLocation","isTimeTraveling","unsubscribeFromStore","unsubscribeFromHistory","currentLocation","getLocationInStore","useInitialIfEmpty","handleStoreChange","locationInStore","transitionTo","subscribe","handleLocationChange","location","dispatch","listen","getCurrentLocation","listener","lastPublishedLocation","unsubscribed","unsubscribe","routing"],"mappings":"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","file":"0.44588aa174ae0aace1fd.hot-update.js","sourcesContent":["webpackHotUpdate(0,{\n\n/***/ 35:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(0);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = __webpack_require__(1);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _redux = __webpack_require__(2);\n\nvar _reactRouter = __webpack_require__(29);\n\nvar _reactRouterRedux = __webpack_require__(93);\n\nvar _actions = __webpack_require__(6);\n\nvar actions = _interopRequireWildcard(_actions);\n\nvar _title = __webpack_require__(16);\n\nvar _title2 = _interopRequireDefault(_title);\n\nvar _app = __webpack_require__(38);\n\nvar _app2 = _interopRequireDefault(_app);\n\nvar _content = __webpack_require__(18);\n\nvar _content2 = _interopRequireDefault(_content);\n\nvar _increase = __webpack_require__(20);\n\nvar _increase2 = _interopRequireDefault(_increase);\n\nvar _decrease = __webpack_require__(19);\n\nvar _decrease2 = _interopRequireDefault(_decrease);\n\nvar _historyMiddle = __webpack_require__(41);\n\nvar _historyMiddle2 = _interopRequireDefault(_historyMiddle);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n//UI 组件\nvar Index = function (_React$Component) {\n  _inherits(Index, _React$Component);\n\n  function Index(props) {\n    _classCallCheck(this, Index);\n\n    // 类构造函数(class constructor) 初始化 \n    return _possibleConstructorReturn(this, (Index.__proto__ || Object.getPrototypeOf(Index)).call(this, props));\n    //组件需要与用户互动，React 就是将组件看成是一个状态机，\n    //一开始有一个初始状态this.state，然后和用户互动，导致状态变化，从而触发重新渲染 UI \n    //当用户点击组件，导致状态变化，this.setState 方法就是修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。\n    //设置默认的state\n    //不能直接修改 state(状态)，唯一可以分配 this.state 的地方是构造函数。\n  }\n\n  _createClass(Index, [{\n    key: 'componentWillMount',\n    value: function componentWillMount() {//在组件装载发生之前立即被调用。 \n      //它在 render() 之前调用，因此在此方法中的设置 state(状态) 不会触发重新渲染。 \n\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      //在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 \n      //如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。\n    }\n  }, {\n    key: 'componentWillUpdate',\n    value: function componentWillUpdate(nextProps, nextState) {\n      //在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      //在组件完成更新后立即调用。在初始化时不会被调用。\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      //在组件从 DOM 中移除的时候立刻被调用。\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      //在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。\n    }\n  }, {\n    key: 'shouldComponentUpdate',\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      //返回一个布尔值,组件判断是否重新渲染时调用.\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      //输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。它可以是一个函数，也可以是一个对象。做出不同的处理\n      //const { count, onIncreaseClick,onDecreaseClick } = this.props //对象\n      return _react2.default.createElement(CountContent, null);\n    }\n  }]);\n\n  return Index;\n}(_react2.default.Component);\n\nvar CountContent = function (_React$Component2) {\n  _inherits(CountContent, _React$Component2);\n\n  function CountContent() {\n    _classCallCheck(this, CountContent);\n\n    return _possibleConstructorReturn(this, (CountContent.__proto__ || Object.getPrototypeOf(CountContent)).apply(this, arguments));\n  }\n\n  _createClass(CountContent, [{\n    key: 'btnTest',\n    value: function btnTest(e) {\n      console.log(e);\n    }\n  }, {\n    key: 'hasData',\n    value: function hasData() {\n\n      return _react2.default.createElement(\n        _reactRouter.Router,\n        { history: _reactRouter.browserHistory },\n        _react2.default.createElement(_reactRouter.Route, { path: '/', component: _app2.default })\n      );\n    }\n  }, {\n    key: 'noData',\n    value: function noData() {\n      return _react2.default.createElement(\n        'div',\n        null,\n        _react2.default.createElement(\n          'div',\n          { className: 'title' },\n          '\\u8FD9\\u662F\\u4E00\\u4E2A\\u5927\\u8089\\u5305'\n        )\n      );\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return this.hasData();\n    }\n  }]);\n\n  return CountContent;\n}(_react2.default.Component);\n\nexports.default = Index;\n\n/***/ }),\n\n/***/ 91:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * This action type will be dispatched by the history actions below.\n * If you're writing a middleware to watch for navigation events, be sure to\n * look for actions of this type.\n */\nvar CALL_HISTORY_METHOD = exports.CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';\n\nfunction updateLocation(method) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return {\n      type: CALL_HISTORY_METHOD,\n      payload: { method: method, args: args }\n    };\n  };\n}\n\n/**\n * These actions correspond to the history API.\n * The associated routerMiddleware will capture these events before they get to\n * your reducer and reissue them as the matching function on your history.\n */\nvar push = exports.push = updateLocation('push');\nvar replace = exports.replace = updateLocation('replace');\nvar go = exports.go = updateLocation('go');\nvar goBack = exports.goBack = updateLocation('goBack');\nvar goForward = exports.goForward = updateLocation('goForward');\n\nvar routerActions = exports.routerActions = { push: push, replace: replace, go: go, goBack: goBack, goForward: goForward };\n\n/***/ }),\n\n/***/ 92:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.routerReducer = routerReducer;\n/**\n * This action type will be dispatched when your history\n * receives a location change.\n */\nvar LOCATION_CHANGE = exports.LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\n\nvar initialState = {\n  locationBeforeTransitions: null\n};\n\n/**\n * This reducer will update the state with the most recent location history\n * has transitioned to. This may not be in sync with the router, particularly\n * if you have asynchronously-loaded routes, so reading from and relying on\n * this state is discouraged.\n */\nfunction routerReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      type = _ref.type,\n      payload = _ref.payload;\n\n  if (type === LOCATION_CHANGE) {\n    return _extends({}, state, { locationBeforeTransitions: payload });\n  }\n\n  return state;\n}\n\n/***/ }),\n\n/***/ 93:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.routerMiddleware = exports.routerActions = exports.goForward = exports.goBack = exports.go = exports.replace = exports.push = exports.CALL_HISTORY_METHOD = exports.routerReducer = exports.LOCATION_CHANGE = exports.syncHistoryWithStore = undefined;\n\nvar _reducer = __webpack_require__(92);\n\nObject.defineProperty(exports, 'LOCATION_CHANGE', {\n  enumerable: true,\n  get: function get() {\n    return _reducer.LOCATION_CHANGE;\n  }\n});\nObject.defineProperty(exports, 'routerReducer', {\n  enumerable: true,\n  get: function get() {\n    return _reducer.routerReducer;\n  }\n});\n\nvar _actions = __webpack_require__(91);\n\nObject.defineProperty(exports, 'CALL_HISTORY_METHOD', {\n  enumerable: true,\n  get: function get() {\n    return _actions.CALL_HISTORY_METHOD;\n  }\n});\nObject.defineProperty(exports, 'push', {\n  enumerable: true,\n  get: function get() {\n    return _actions.push;\n  }\n});\nObject.defineProperty(exports, 'replace', {\n  enumerable: true,\n  get: function get() {\n    return _actions.replace;\n  }\n});\nObject.defineProperty(exports, 'go', {\n  enumerable: true,\n  get: function get() {\n    return _actions.go;\n  }\n});\nObject.defineProperty(exports, 'goBack', {\n  enumerable: true,\n  get: function get() {\n    return _actions.goBack;\n  }\n});\nObject.defineProperty(exports, 'goForward', {\n  enumerable: true,\n  get: function get() {\n    return _actions.goForward;\n  }\n});\nObject.defineProperty(exports, 'routerActions', {\n  enumerable: true,\n  get: function get() {\n    return _actions.routerActions;\n  }\n});\n\nvar _sync = __webpack_require__(95);\n\nvar _sync2 = _interopRequireDefault(_sync);\n\nvar _middleware = __webpack_require__(94);\n\nvar _middleware2 = _interopRequireDefault(_middleware);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nexports.syncHistoryWithStore = _sync2['default'];\nexports.routerMiddleware = _middleware2['default'];\n\n/***/ }),\n\n/***/ 94:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = routerMiddleware;\n\nvar _actions = __webpack_require__(91);\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * This middleware captures CALL_HISTORY_METHOD actions to redirect to the\n * provided history object. This will prevent these actions from reaching your\n * reducer or any middleware that comes after this one.\n */\nfunction routerMiddleware(history) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type !== _actions.CALL_HISTORY_METHOD) {\n          return next(action);\n        }\n\n        var _action$payload = action.payload,\n            method = _action$payload.method,\n            args = _action$payload.args;\n\n        history[method].apply(history, _toConsumableArray(args));\n      };\n    };\n  };\n}\n\n/***/ }),\n\n/***/ 95:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports['default'] = syncHistoryWithStore;\n\nvar _reducer = __webpack_require__(92);\n\nvar defaultSelectLocationState = function defaultSelectLocationState(state) {\n  return state.routing;\n};\n\n/**\n * This function synchronizes your history state with the Redux store.\n * Location changes flow from history to the store. An enhanced history is\n * returned with a listen method that responds to store updates for location.\n *\n * When this history is provided to the router, this means the location data\n * will flow like this:\n * history.push -> store.dispatch -> enhancedHistory.listen -> router\n * This ensures that when the store state changes due to a replay or other\n * event, the router will be updated appropriately and can transition to the\n * correct router state.\n */\nfunction syncHistoryWithStore(history, store) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$selectLocationSt = _ref.selectLocationState,\n      selectLocationState = _ref$selectLocationSt === undefined ? defaultSelectLocationState : _ref$selectLocationSt,\n      _ref$adjustUrlOnRepla = _ref.adjustUrlOnReplay,\n      adjustUrlOnReplay = _ref$adjustUrlOnRepla === undefined ? true : _ref$adjustUrlOnRepla;\n\n  // Ensure that the reducer is mounted on the store and functioning properly.\n  if (typeof selectLocationState(store.getState()) === 'undefined') {\n    throw new Error('Expected the routing state to be available either as `state.routing` ' + 'or as the custom expression you can specify as `selectLocationState` ' + 'in the `syncHistoryWithStore()` options. ' + 'Ensure you have added the `routerReducer` to your store\\'s ' + 'reducers via `combineReducers` or whatever method you use to isolate ' + 'your reducers.');\n  }\n\n  var initialLocation = void 0;\n  var isTimeTraveling = void 0;\n  var unsubscribeFromStore = void 0;\n  var unsubscribeFromHistory = void 0;\n  var currentLocation = void 0;\n\n  // What does the store say about current location?\n  var getLocationInStore = function getLocationInStore(useInitialIfEmpty) {\n    var locationState = selectLocationState(store.getState());\n    return locationState.locationBeforeTransitions || (useInitialIfEmpty ? initialLocation : undefined);\n  };\n\n  // Init initialLocation with potential location in store\n  initialLocation = getLocationInStore();\n\n  // If the store is replayed, update the URL in the browser to match.\n  if (adjustUrlOnReplay) {\n    var handleStoreChange = function handleStoreChange() {\n      var locationInStore = getLocationInStore(true);\n      if (currentLocation === locationInStore || initialLocation === locationInStore) {\n        return;\n      }\n\n      // Update address bar to reflect store state\n      isTimeTraveling = true;\n      currentLocation = locationInStore;\n      history.transitionTo(_extends({}, locationInStore, {\n        action: 'PUSH'\n      }));\n      isTimeTraveling = false;\n    };\n\n    unsubscribeFromStore = store.subscribe(handleStoreChange);\n    handleStoreChange();\n  }\n\n  // Whenever location changes, dispatch an action to get it in the store\n  var handleLocationChange = function handleLocationChange(location) {\n    // ... unless we just caused that location change\n    if (isTimeTraveling) {\n      return;\n    }\n\n    // Remember where we are\n    currentLocation = location;\n\n    // Are we being called for the first time?\n    if (!initialLocation) {\n      // Remember as a fallback in case state is reset\n      initialLocation = location;\n\n      // Respect persisted location, if any\n      if (getLocationInStore()) {\n        return;\n      }\n    }\n\n    // Tell the store to update by dispatching an action\n    store.dispatch({\n      type: _reducer.LOCATION_CHANGE,\n      payload: location\n    });\n  };\n  unsubscribeFromHistory = history.listen(handleLocationChange);\n\n  // History 3.x doesn't call listen synchronously, so fire the initial location change ourselves\n  if (history.getCurrentLocation) {\n    handleLocationChange(history.getCurrentLocation());\n  }\n\n  // The enhanced history uses store as source of truth\n  return _extends({}, history, {\n    // The listeners are subscribed to the store instead of history\n    listen: function listen(listener) {\n      // Copy of last location.\n      var lastPublishedLocation = getLocationInStore(true);\n\n      // Keep track of whether we unsubscribed, as Redux store\n      // only applies changes in subscriptions on next dispatch\n      var unsubscribed = false;\n      var unsubscribeFromStore = store.subscribe(function () {\n        var currentLocation = getLocationInStore(true);\n        if (currentLocation === lastPublishedLocation) {\n          return;\n        }\n        lastPublishedLocation = currentLocation;\n        if (!unsubscribed) {\n          listener(lastPublishedLocation);\n        }\n      });\n\n      // History 2.x listeners expect a synchronous call. Make the first call to the\n      // listener after subscribing to the store, in case the listener causes a\n      // location change (e.g. when it redirects)\n      if (!history.getCurrentLocation) {\n        listener(lastPublishedLocation);\n      }\n\n      // Let user unsubscribe later\n      return function () {\n        unsubscribed = true;\n        unsubscribeFromStore();\n      };\n    },\n\n\n    // It also provides a way to destroy internal listeners\n    unsubscribe: function unsubscribe() {\n      if (adjustUrlOnReplay) {\n        unsubscribeFromStore();\n      }\n      unsubscribeFromHistory();\n    }\n  });\n}\n\n/***/ })\n\n})\n\n\n// WEBPACK FOOTER //\n// 0.44588aa174ae0aace1fd.hot-update.js","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { bindActionCreators } from 'redux';\nimport { Router, Route, browserHistory } from 'react-router';\nimport { syncHistoryWithStore, routerReducer } from 'react-router-redux';\nimport  * as actions from '../actions'\nimport Title from './title';\nimport App from './app';\nimport Content from '../containers/content';\nimport Increase from '../containers/increase';\nimport Decrease from '../containers/decrease';\nimport History from './historyMiddle';\n\n\n//UI 组件\nclass Index extends React.Component {\n  constructor(props) {// 类构造函数(class constructor) 初始化 \n    super(props);\n    //组件需要与用户互动，React 就是将组件看成是一个状态机，\n    //一开始有一个初始状态this.state，然后和用户互动，导致状态变化，从而触发重新渲染 UI \n    //当用户点击组件，导致状态变化，this.setState 方法就是修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。\n    //设置默认的state\n    //不能直接修改 state(状态)，唯一可以分配 this.state 的地方是构造函数。\n  }\n  componentWillMount(){//在组件装载发生之前立即被调用。 \n    //它在 render() 之前调用，因此在此方法中的设置 state(状态) 不会触发重新渲染。 \n    \n  } \n  componentDidMount(){\n    //在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 \n    //如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。\n  }\n  componentWillUpdate(nextProps,nextState){\n    //在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。\n  }\n  componentDidUpdate(prevProps,prevState){\n    //在组件完成更新后立即调用。在初始化时不会被调用。\n  }\n  componentWillUnmount(){\n    //在组件从 DOM 中移除的时候立刻被调用。\n  }\n  componentWillReceiveProps(nextProps){\n    //在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。\n  }\n  shouldComponentUpdate(nextProps,nextState){\n    //返回一个布尔值,组件判断是否重新渲染时调用.\n  }\n  render() {\n    //输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。它可以是一个函数，也可以是一个对象。做出不同的处理\n    //const { count, onIncreaseClick,onDecreaseClick } = this.props //对象\n    return (<CountContent />);\n  }\n}\n\nclass CountContent extends React.Component{\n  btnTest(e){\n    console.log(e)\n  }\n  hasData(){\n\n    return <Router history={browserHistory}>\n      <Route path=\"/\" component={App} />\n    </Router>  \n\n  }\n  noData(){\n    return (<div>\n        <div className=\"title\">这是一个大肉包</div>\n      </div>);\n  }\n  render(){\n    return this.hasData();\n  }\n}\n\n\nexport default Index;\n\n\n\n\n// WEBPACK FOOTER //\n// ./public/client/components/index.js","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * This action type will be dispatched by the history actions below.\n * If you're writing a middleware to watch for navigation events, be sure to\n * look for actions of this type.\n */\nvar CALL_HISTORY_METHOD = exports.CALL_HISTORY_METHOD = '@@router/CALL_HISTORY_METHOD';\n\nfunction updateLocation(method) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return {\n      type: CALL_HISTORY_METHOD,\n      payload: { method: method, args: args }\n    };\n  };\n}\n\n/**\n * These actions correspond to the history API.\n * The associated routerMiddleware will capture these events before they get to\n * your reducer and reissue them as the matching function on your history.\n */\nvar push = exports.push = updateLocation('push');\nvar replace = exports.replace = updateLocation('replace');\nvar go = exports.go = updateLocation('go');\nvar goBack = exports.goBack = updateLocation('goBack');\nvar goForward = exports.goForward = updateLocation('goForward');\n\nvar routerActions = exports.routerActions = { push: push, replace: replace, go: go, goBack: goBack, goForward: goForward };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_react-router-redux@4.0.8@react-router-redux/lib/actions.js\n// module id = 91\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.routerReducer = routerReducer;\n/**\n * This action type will be dispatched when your history\n * receives a location change.\n */\nvar LOCATION_CHANGE = exports.LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\n\nvar initialState = {\n  locationBeforeTransitions: null\n};\n\n/**\n * This reducer will update the state with the most recent location history\n * has transitioned to. This may not be in sync with the router, particularly\n * if you have asynchronously-loaded routes, so reading from and relying on\n * this state is discouraged.\n */\nfunction routerReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      type = _ref.type,\n      payload = _ref.payload;\n\n  if (type === LOCATION_CHANGE) {\n    return _extends({}, state, { locationBeforeTransitions: payload });\n  }\n\n  return state;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_react-router-redux@4.0.8@react-router-redux/lib/reducer.js\n// module id = 92\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.routerMiddleware = exports.routerActions = exports.goForward = exports.goBack = exports.go = exports.replace = exports.push = exports.CALL_HISTORY_METHOD = exports.routerReducer = exports.LOCATION_CHANGE = exports.syncHistoryWithStore = undefined;\n\nvar _reducer = require('./reducer');\n\nObject.defineProperty(exports, 'LOCATION_CHANGE', {\n  enumerable: true,\n  get: function get() {\n    return _reducer.LOCATION_CHANGE;\n  }\n});\nObject.defineProperty(exports, 'routerReducer', {\n  enumerable: true,\n  get: function get() {\n    return _reducer.routerReducer;\n  }\n});\n\nvar _actions = require('./actions');\n\nObject.defineProperty(exports, 'CALL_HISTORY_METHOD', {\n  enumerable: true,\n  get: function get() {\n    return _actions.CALL_HISTORY_METHOD;\n  }\n});\nObject.defineProperty(exports, 'push', {\n  enumerable: true,\n  get: function get() {\n    return _actions.push;\n  }\n});\nObject.defineProperty(exports, 'replace', {\n  enumerable: true,\n  get: function get() {\n    return _actions.replace;\n  }\n});\nObject.defineProperty(exports, 'go', {\n  enumerable: true,\n  get: function get() {\n    return _actions.go;\n  }\n});\nObject.defineProperty(exports, 'goBack', {\n  enumerable: true,\n  get: function get() {\n    return _actions.goBack;\n  }\n});\nObject.defineProperty(exports, 'goForward', {\n  enumerable: true,\n  get: function get() {\n    return _actions.goForward;\n  }\n});\nObject.defineProperty(exports, 'routerActions', {\n  enumerable: true,\n  get: function get() {\n    return _actions.routerActions;\n  }\n});\n\nvar _sync = require('./sync');\n\nvar _sync2 = _interopRequireDefault(_sync);\n\nvar _middleware = require('./middleware');\n\nvar _middleware2 = _interopRequireDefault(_middleware);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nexports.syncHistoryWithStore = _sync2['default'];\nexports.routerMiddleware = _middleware2['default'];\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_react-router-redux@4.0.8@react-router-redux/lib/index.js\n// module id = 93\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = routerMiddleware;\n\nvar _actions = require('./actions');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * This middleware captures CALL_HISTORY_METHOD actions to redirect to the\n * provided history object. This will prevent these actions from reaching your\n * reducer or any middleware that comes after this one.\n */\nfunction routerMiddleware(history) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        if (action.type !== _actions.CALL_HISTORY_METHOD) {\n          return next(action);\n        }\n\n        var _action$payload = action.payload,\n            method = _action$payload.method,\n            args = _action$payload.args;\n\n        history[method].apply(history, _toConsumableArray(args));\n      };\n    };\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_react-router-redux@4.0.8@react-router-redux/lib/middleware.js\n// module id = 94\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports['default'] = syncHistoryWithStore;\n\nvar _reducer = require('./reducer');\n\nvar defaultSelectLocationState = function defaultSelectLocationState(state) {\n  return state.routing;\n};\n\n/**\n * This function synchronizes your history state with the Redux store.\n * Location changes flow from history to the store. An enhanced history is\n * returned with a listen method that responds to store updates for location.\n *\n * When this history is provided to the router, this means the location data\n * will flow like this:\n * history.push -> store.dispatch -> enhancedHistory.listen -> router\n * This ensures that when the store state changes due to a replay or other\n * event, the router will be updated appropriately and can transition to the\n * correct router state.\n */\nfunction syncHistoryWithStore(history, store) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$selectLocationSt = _ref.selectLocationState,\n      selectLocationState = _ref$selectLocationSt === undefined ? defaultSelectLocationState : _ref$selectLocationSt,\n      _ref$adjustUrlOnRepla = _ref.adjustUrlOnReplay,\n      adjustUrlOnReplay = _ref$adjustUrlOnRepla === undefined ? true : _ref$adjustUrlOnRepla;\n\n  // Ensure that the reducer is mounted on the store and functioning properly.\n  if (typeof selectLocationState(store.getState()) === 'undefined') {\n    throw new Error('Expected the routing state to be available either as `state.routing` ' + 'or as the custom expression you can specify as `selectLocationState` ' + 'in the `syncHistoryWithStore()` options. ' + 'Ensure you have added the `routerReducer` to your store\\'s ' + 'reducers via `combineReducers` or whatever method you use to isolate ' + 'your reducers.');\n  }\n\n  var initialLocation = void 0;\n  var isTimeTraveling = void 0;\n  var unsubscribeFromStore = void 0;\n  var unsubscribeFromHistory = void 0;\n  var currentLocation = void 0;\n\n  // What does the store say about current location?\n  var getLocationInStore = function getLocationInStore(useInitialIfEmpty) {\n    var locationState = selectLocationState(store.getState());\n    return locationState.locationBeforeTransitions || (useInitialIfEmpty ? initialLocation : undefined);\n  };\n\n  // Init initialLocation with potential location in store\n  initialLocation = getLocationInStore();\n\n  // If the store is replayed, update the URL in the browser to match.\n  if (adjustUrlOnReplay) {\n    var handleStoreChange = function handleStoreChange() {\n      var locationInStore = getLocationInStore(true);\n      if (currentLocation === locationInStore || initialLocation === locationInStore) {\n        return;\n      }\n\n      // Update address bar to reflect store state\n      isTimeTraveling = true;\n      currentLocation = locationInStore;\n      history.transitionTo(_extends({}, locationInStore, {\n        action: 'PUSH'\n      }));\n      isTimeTraveling = false;\n    };\n\n    unsubscribeFromStore = store.subscribe(handleStoreChange);\n    handleStoreChange();\n  }\n\n  // Whenever location changes, dispatch an action to get it in the store\n  var handleLocationChange = function handleLocationChange(location) {\n    // ... unless we just caused that location change\n    if (isTimeTraveling) {\n      return;\n    }\n\n    // Remember where we are\n    currentLocation = location;\n\n    // Are we being called for the first time?\n    if (!initialLocation) {\n      // Remember as a fallback in case state is reset\n      initialLocation = location;\n\n      // Respect persisted location, if any\n      if (getLocationInStore()) {\n        return;\n      }\n    }\n\n    // Tell the store to update by dispatching an action\n    store.dispatch({\n      type: _reducer.LOCATION_CHANGE,\n      payload: location\n    });\n  };\n  unsubscribeFromHistory = history.listen(handleLocationChange);\n\n  // History 3.x doesn't call listen synchronously, so fire the initial location change ourselves\n  if (history.getCurrentLocation) {\n    handleLocationChange(history.getCurrentLocation());\n  }\n\n  // The enhanced history uses store as source of truth\n  return _extends({}, history, {\n    // The listeners are subscribed to the store instead of history\n    listen: function listen(listener) {\n      // Copy of last location.\n      var lastPublishedLocation = getLocationInStore(true);\n\n      // Keep track of whether we unsubscribed, as Redux store\n      // only applies changes in subscriptions on next dispatch\n      var unsubscribed = false;\n      var unsubscribeFromStore = store.subscribe(function () {\n        var currentLocation = getLocationInStore(true);\n        if (currentLocation === lastPublishedLocation) {\n          return;\n        }\n        lastPublishedLocation = currentLocation;\n        if (!unsubscribed) {\n          listener(lastPublishedLocation);\n        }\n      });\n\n      // History 2.x listeners expect a synchronous call. Make the first call to the\n      // listener after subscribing to the store, in case the listener causes a\n      // location change (e.g. when it redirects)\n      if (!history.getCurrentLocation) {\n        listener(lastPublishedLocation);\n      }\n\n      // Let user unsubscribe later\n      return function () {\n        unsubscribed = true;\n        unsubscribeFromStore();\n      };\n    },\n\n\n    // It also provides a way to destroy internal listeners\n    unsubscribe: function unsubscribe() {\n      if (adjustUrlOnReplay) {\n        unsubscribeFromStore();\n      }\n      unsubscribeFromHistory();\n    }\n  });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/_react-router-redux@4.0.8@react-router-redux/lib/sync.js\n// module id = 95\n// module chunks = 0"],"sourceRoot":""}